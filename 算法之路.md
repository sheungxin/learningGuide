# 数组系列

## [350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)

### 描述

给定两个数组，编写一个函数来计算它们的交集。

**示例 1：**

```java
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
```

**示例 2:**

```java
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```

**说明：**

- 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致
- 我们可以不考虑输出结果的顺序

**进阶：**

- 如果给定的数组已经排好序呢？你将如何优化你的算法？（实践三，没有排序开销，时间复杂度更低）
- 如果 nums1 的大小比 nums2 小很多，哪种方法更优？（实践三，）
- 如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？（实践二，没有排序不需要加载nums2全部内容，只需要为nums1构建HashMap结构）

### 实践一

计算每个元素在各个数组中出现的次数，以出现次数最小值作为实际输出次数，代码如下：

```java
public static int[] intersect(int[] nums1, int[] nums2) {
    // 构建并存储数组nums1元素出现次数
    Map<Integer, Integer> map1 = new HashMap<>(nums1.length);
    for (int value : nums1) {
        if (map1.containsKey(value)) {
            map1.put(value, map1.get(value) + 1);
        } else {
            map1.put(value, 1);
        }
    }
    // 构建并存储数组nums2元素出现次数
    Map<Integer, Integer> map2 = new HashMap<>(nums2.length);
    for (int value : nums2) {
        if (map2.containsKey(value)) {
            map2.put(value, map2.get(value) + 1);
        } else {
            map2.put(value, 1);
        }
    }
    // 交集元素个数
    int n = 0;
    // 循环任意一个HashMap结构，删除在另一个数组不存在的元素，并更新元素出现次数为两个数组中出现次数的最小值
    for (Iterator<Map.Entry<Integer, Integer>> it = map1.entrySet().iterator(); it.hasNext(); ) {
        Map.Entry<Integer, Integer> item = it.next();
        if (map2.containsKey(item.getKey())) {
            if (item.getValue() > map2.get(item.getKey())) {
                map1.put(item.getKey(), map2.get(item.getKey()));
            }
            n += map1.get(item.getKey());
        } else {
            it.remove();
        }
    }
    // 构建交集元素数组
    int[] result = new int[n];
    int ix = 0;
    // 循环交集元素次数的HashMap构建交集数组
    for (Map.Entry<Integer, Integer> entry : map1.entrySet()) {
        for (int i = 0; i < entry.getValue(); i++) {
            result[ix++] = entry.getKey();
        }
    }
    return result;
}
```

### 实践二

计算数组中元素出现次数构建了两个HashMap，能否减少空间占用？

可以先构建一个HashMap存储小数组中元素的出现次数，然后遍历另一个数组，判断是否存在HashMap中，若存在保存在结果集中，并扣减出现次数，直到扣减为0后从HashMap中删除。

为什么为构建小数组构建HashMap？大概率空间占用小，不排除大数组中存在大量重复元素

```java
public static int[] intersect2(int[] nums1, int[] nums2) {
    // 优先为小数组构建HashMap结构存储元素出现次数
    if (nums1.length > nums2.length) {
        return intersect2(nums2, nums1);
    }
    // 构建并存储元素出现次数
    Map<Integer, Integer> map = new HashMap<>(nums1.length);
    for (Integer v : nums1) {
        int count = map.getOrDefault(v, 0) + 1;
        map.put(v, count);
    }
    // 交集数组中当前存储下标
    int ix = 0;
    for (Integer v : nums2) {
        // 判断另一个数组中元素是否存在已构建的HashMap中，不要使用containsKey(),直接获取value，下面需要用到
        int count = map.getOrDefault(v, 0);
        if (count > 0) {
            // 存在加入交集数组（使用nums1存储）
            nums1[ix++] = v;
            // 扣减存在次数
            count--;
            // 更新存在次数，为0就可以直接删除该key（删除是为了尽快释放空间占用）
            if (count == 0) {
                map.remove(v);
            } else {
                map.put(v, count);
            }
        }
    }
    // 数组截取返回实际交集元素
    return Arrays.copyOfRange(nums1, 0, ix);
}
```

**复杂度分析**

- 时间复杂度：O(m+n)，其中 m 和 n 分别是两个数组的长度。需要遍历两个数组并对哈希表进行操作，哈希表操作的时间复杂度是 O(1)，因此总时间复杂度与两个数组的长度和呈线性关系。
- 空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个数组的长度。对较短的数组进行哈希表的操作，哈希表的大小不会超过较短的数组的长度。交集数组长度也小于较短数组的长度

### 实践三

如果两个数组是有序的，则可以便捷地计算两个数组的交集。

首先对两个数组进行排序，然后使用两个指针遍历两个数组。

初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。

```java
 public static int[] intersect3(int[] nums1, int[] nums2) {
     Arrays.sort(nums1);
     Arrays.sort(nums2);
     int length1 = nums1.length;
     int length2 = nums2.length;
     int a = 0;
     int b = 0;
     int[] r = new int[Math.min(length1, length2)];
     int ix = 0;
     while (a < length1 && b < length2) {
         if (nums1[a] == nums2[b]) {
             r[ix++] = nums1[a];
             a++;
             b++;
         } else if (nums1[a] > nums2[b]) {
             b++;
         } else {
             a++;
         }
     }
     return Arrays.copyOfRange(r, 0, ix);
 }
```

**复杂度分析**

- 时间复杂度：O(mlogm+nlogn)，其中 m 和 n 分别是两个数组的长度。对两个数组进行排序的时间复杂度是 O(mlogm+nlogn)，遍历两个数组的时间复杂度是 O(m+n)，因此总时间复杂度是 O(mlogm+nlogn)

- 空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个数组的长度。为返回值创建一个数组 r，其长度为较短的数组的长度。未考虑排序空间开销
