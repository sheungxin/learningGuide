# 排序算法

## 算法分类

![img](%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%AF.assets/849589-20180402133438219-1946132192.png)

> [十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/articles/7674659.html)

## 算法实践

```java
package learning.sort;

import java.lang.reflect.Method;
import java.util.*;

/**
 * 排序算法集合
 * 交换排序：冒泡排序、快速排序、三路切分快速排序
 * 选择排序：简单选择排序、希尔排序
 * 插入排序：直接插入排序、堆排序
 * 归并排序
 * 非比较排序：桶排序、计数排序、基数排序
 */
public class NumberSort {

    /**
     * 交换排序之冒泡排序：相邻的两个值相比较交换位置，把最大值交换到最右边，缩小范围重复上述步骤
     *
     * @param array 数组
     */
    public static void bubbleSort(int[] array) {
        // 是否已排序
        boolean isSorted = false;
        for (int i = 0; i < array.length - 1 && !isSorted; i++) {
            // 默认本次交换后已经有序（如果不发生交换就已经有序了）
            isSorted = true;
            /*
            从下标1开始依次与前一个数比较交换位置
            1、为什么从下标1开始？
            与前一个数比较不会存在越界问题
            2、截止为什么是array.length - i？
            每一次依次相邻比较并交换后会把最大值移到最右边，不用再参与排序
             */
            for (int j = 1; j < array.length - i; j++) {
                // 前一个数较大，交换位置
                if (array[j - 1] > array[j]) {
                    swap(array, j - 1, j);
                    isSorted = false;
                }
            }
        }
    }

    /**
     * 交换排序之快速排序：通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素。
     * 通过上述规则不断切分左右子数组，直到各子区间只有一个数为止整个数组就有序了
     *
     * @param array 数组
     */
    public static void quickSort(int[] array) {
        quickSort(array, 0, array.length - 1);
    }

    /**
     * 快排辅助方法
     *
     * @param array 数组
     * @param left  左边界下标
     * @param right 右边界下标
     */
    private static void quickSort(int[] array, int left, int right) {
        // 左边界大于等于右边界中断
        if (left >= right) {
            return;
        }
        // 左边开始下标
        int i = left;
        // 右边开始下标
        int j = right;
        // 基准数，这里取左边第一个数，且作为首个空位
        int base = array[i];
        // 左右边界向中间移动直到相遇
        while (i < j) {
            // 右边开始查找第一个小于基准数的下标
            while (i < j && array[j] >= base) {
                j--;
            }
            // 如果在右边找到小于基准数的值，放在数组左边空位（首个空位是基准数所在下标），下标i向右移动
            if (i < j) {
                // 右边形成一个新的空位array[j]
                array[i++] = array[j];
            }
            // 左边开始查找第一个大于基准数的下标
            while (i < j && array[i] <= base) {
                i++;
            }
            // 如果在左边找到大于基准数的值，放在数组右边空位array[j]，下标j向左移动
            if (i < j) {
                // 左边形成一个新的空位array[i]
                array[j--] = array[i];
            }
        }
        // 退出时i等于j，将基准数放入即可
        array[j] = base;
        // 左边子数组重复上述步骤
        quickSort(array, left, i - 1);
        // 右边子数组重复上述步骤
        quickSort(array, i + 1, right);
    }

    /**
     * 三向切分快速排序：将数组分为三部分：小于当前切分元素的部分、等于当前切分元素的部分、大于当前切分元素的部分，中间部分不再切分
     * 好处在于若存在大量重复元素，重复元素总会位于中间部分，不再切分为更小数组，可以在线性时间内完成排序
     *
     * @param array 数组
     */
    public static void threeWayQuickSort(int[] array) {
        threeWayQuickSort(array, 0, array.length - 1);
    }

    /**
     * 三向切分快排辅助方法
     *
     * @param array 数组
     * @param left  左边界下标
     * @param right 右边界下标
     */
    private static void threeWayQuickSort(int[] array, int left, int right) {
        // 左边界大于等于右边界中断
        if (left >= right) {
            return;
        }
        // 基准下标
        int lt = left;
        // 左子数组开始下标
        int i = left + 1;
        // 右子数组开始下标
        int j = right;
        // 基准数
        int base = array[left];
        // 遍历左右下标直到相遇（注意需要包含等于）
        while (i <= j) {
            // 小于基准数放入基准数所在下标，基准数下标右移，相当于放在其左边
            if (array[i] < base) {
                swap(array, lt++, i++);
                // 大于基准数，和右边界数据交换位置，且缩小右边界，左边界下标不变重复第一步
            } else if (array[i] > base) {
                swap(array, i, j--);
                // 等于基准数，左边界右移即可
            } else {
                i++;
            }
        }
        // 小于基准数组成左子数组重复上述步骤
        threeWayQuickSort(array, left, lt - 1);
        // 大于基准数组成右子数组重复上述步骤
        threeWayQuickSort(array, j + 1, right);
    }

    /**
     * 选择排序之简单选择排序：每次选择最小值放在左边有序部分尾部
     *
     * @param array 数组
     */
    public static void selectionSort(int[] array) {
        // 从0~array.length - 2依次默认当前位置为最小值，在右边寻找真实最小值交换位置
        for (int i = 0; i < array.length - 1; i++) {
            // 默认当前下标i为最小值
            int min = i;
            // 在右边寻找真实最小值下标
            for (int j = i + 1; j < array.length; j++) {
                if (array[min] > array[j]) {
                    min = j;
                }
            }
            // 如果最小下标不是当前默认位置，交换位置
            if (i != min) {
                swap(array, i, min);
            }
        }
    }

    /**
     * 选择排序之堆排序：构建数组二叉堆(近似完全二叉树)，利用父节点总是小于（大于）或等于任何一个子节点的特性，
     * 根节点总是最大或最小值，摘除根节点加入有序序列，重新构建数组二叉堆重复上述步骤即可
     *
     * @param array 数组
     */
    public static void heapSort(int[] array) {
        int n = 2;
        /*
        构建二叉堆，从最后一个父节点开始
        1、为什么最后一个父节点是array.length / 2 - 1？
        最后一个元素下标i为array.length-1，根据父节点下标公式(i-1)/2得出，其父节点为(array.length-1-1)/2=array.length / 2 - 1）
        2、为什么从最后一个父节点开始？
        二叉堆父节点总是大于(小于)或等于任何一个子节点。靠后的父节点也是子节点，从下层开始才能把较大(较小)节点上浮
         */
        for (int i = array.length / n - 1; i >= 0; i--) {
            buildHeap(array, array.length, i);
        }
        /*
        二叉堆已构建，利用根节点总是最大(最小)的特性进行排序，把根节点交换到右侧后缩小数组范围重新构建二叉堆，重复上述步骤
        i表示数组无序部分截止下标，交换到右侧的已经有序了，i缩小到0后整个数组就有序了
         */
        for (int i = array.length - 1; i > 0; i--) {
            // 交换根节点到最右侧
            swap(array, 0, i);
            // 交换后破坏了二叉堆结构，需要重新构建
            buildHeap(array, i, 0);
        }
    }

    /**
     * 构建二叉堆(升序构建最大堆，降序构建最小堆)
     *
     * @param array 数组
     * @param len   数组长度（构建二叉堆部分长度，排序时右侧部分逐渐有序，不参与堆结构构建）
     * @param index 父节点下标
     */
    private static void buildHeap(int[] array, int len, int index) {
        // 父节点下标越界中断
        while (index < len) {
            // 左子节点，右子节点为left+1
            int left = 2 * index + 1;
            // 左子节点下标越界，证明没有子节点不需要调整位置
            if (left >= len) {
                break;
            }
            // 默认左子节点较大
            int max = left;
            // 与右子节点比较，得出最大值下标
            if (left + 1 < len && array[left + 1] > array[max]) {
                max = left + 1;
            }
            // 与父节点比较，若小于父节点不需要交换位置，中断循环
            if (array[max] < array[index]) {
                break;
            }
            // 若大于父节点交换位置
            swap(array, max, index);
            // 交换位置后，破坏了下层最大(小)堆结构，重置父节点进入下次循环
            index = max;
        }
    }

    /**
     * 插入排序之直接插入排序：左边有序，从右边无序节点中依次选择节点，插入到左边合适的位置（从右向左扫描）
     *
     * @param array 数组
     */
    public static void straightInsertSort(int[] array) {
        // 左边默认一个元素且有序，右边无序元素从下标1开始
        for (int i = 1; i < array.length; i++) {
            // 与左边元素比较找到第一个小于的元素位置为止
            for (int j = i; j > 0 && array[j - 1] > array[j]; j--) {
                // 若左边的元素较大，交换位置，重复上述步骤找到合适位置
                swap(array, j, j - 1);
            }
        }
    }


    /**
     * 插入排序之希尔排序：本质上是多次的直接插入排序，通过步长构建新的子序列后进行直接插入排序，缩减步长重复上述步骤，
     * 直到步长为1(步长为1时其实就是直接插入排序)，好处在于直接插入排序在数据量小且有序的情况下效率最高
     *
     * @param array 数组
     */
    public static void shellSort(int[] array) {
        // 构建不断缩小的步长直到为1
        int n = 2;
        for (int gap = array.length / n; gap > 0; gap /= n) {
            // 根据步长构建新的子序列进行直接插入排序
            for (int i = gap; i < array.length; i += gap) {
                for (int j = i; j >= gap && array[j - gap] > array[j]; j -= gap) {
                    swap(array, j - gap, j);
                }
            }
        }
    }

    /**
     * 归并排序：利用单个元素的有序性，反向合并两个有序数组
     *
     * @param array 数组
     */
    public static void mergeSort(int[] array) {
        mergeSort(array, 0, array.length - 1);
    }

    /**
     * 把数组拆分为两个子数组分别排序后再合并，子数组的排序利用一个元素的数组是有序实现（不断拆分）
     *
     * @param array 数组
     * @param left  左边界
     * @param right 右边界
     */
    private static void mergeSort(int[] array, int left, int right) {
        // 左右边界未相遇，即只有一个元素（有序）
        if (left < right) {
            // 确认中间分界线
            int mid = (left + right) / 2;
            // 递归左子数组
            mergeSort(array, left, mid);
            // 递归右子数组
            mergeSort(array, mid + 1, right);
            // 合并左右有序数组
            mergeSort(array, left, mid, right);
        }
    }

    /**
     * 合并左右有序数组
     *
     * @param array 数组
     * @param left  左边界
     * @param mid   子数组分界线
     * @param right 右边界
     */
    private static void mergeSort(int[] array, int left, int mid, int right) {
        // 存放排序后数组
        int[] temp = new int[right - left + 1];
        // 左子数组开始下标
        int i = left;
        // 右子数组开始下标
        int j = mid + 1;
        // temp当前下标
        int ix = 0;
        // 从两个数组中选择较小的数放入temp中
        while (i <= mid || j <= right) {
            // 左子数组已经空了，直接把右子数组元素放入temp
            if (i > mid) {
                temp[ix++] = array[j++];
                // 右子数组已经空了，直接把左子数组元素放入temp
            } else if (j > right) {
                temp[ix++] = array[i++];
                // 左右子数组都为空，把较小的数组元素放入temp
            } else if (array[i] < array[j]) {
                temp[ix++] = array[i++];
            } else {
                temp[ix++] = array[j++];
            }
        }
        // 把排序后值放入原数组
        for (int n = left; n <= right; n++) {
            array[n] = temp[n - left];
        }
    }

    /**
     * 桶排序：构建多个有序桶，按照一定规则把数据分到不同的桶里，桶内分别排序（直接插入排序），排序后按照桶顺序回放数据
     *
     * @param array 数组
     */
    public static void bucketSort(int[] array) {
        // 默认最大值
        int maxLen = 1;
        // 遍历原数组得出最大值、最小值
        for (int value : array) {
            int len = String.valueOf(value).length();
            if (len > maxLen) {
                maxLen = len;
            }
        }
        // 创建一个桶集合，相同位数的放入同一个桶
        List<LinkedList<Integer>> buckets = new ArrayList<>(maxLen);
        // 初始化桶并加入到桶集合中，频繁插入选用链表结构LinkedList
        for (int i = 0; i < maxLen; i++) {
            buckets.add(new LinkedList<>());
        }
        // 遍历原数据均匀放入对应的桶中
        for (int v : array) {
            // 计算数据对应的桶，根据实际场景设计，保证数据可以均匀分布且桶之间数据有序
            int ix = String.valueOf(v).length() - 1;
            // 有序插入到桶中
            bucketInsert(buckets.get(ix), v);
        }
        // 将桶中元素全部取出插入的原数组中
        int ix = 0;
        for (LinkedList<Integer> bucket : buckets) {
            for (int v : bucket) {
                array[ix++] = v;
            }
        }
    }

    /**
     * 辅助桶排序：有序插入元素
     *
     * @param bucket 桶
     * @param data   待插入数据
     */
    private static void bucketInsert(List<Integer> bucket, int data) {
        // 是否插入元素
        boolean insertFlag = true;
        // 使用迭代器遍历桶
        ListIterator<Integer> it = bucket.listIterator();
        while (it.hasNext()) {
            // 如果待插入数据小于等于当前元素，就是需要插入的位置
            if (data <= it.next()) {
                // 迭代器位置偏移回上一个位置
                it.previous();
                // 位置偏移后插入元素，刚好就在本次比较元素之前
                it.add(data);
                // 元素已插入修改插入标志
                insertFlag = false;
                // 中断循环
                break;
            }
        }
        // 如果迭代过程没有插入说明待插入数据最大，插入到末尾
        if (insertFlag) {
            bucket.add(data);
        }
    }

    /**
     * 计数排序：本质上是一个特殊的桶排序，当桶的个数最大的时候，即相同的数一个桶，就是计数排序
     * 创建一个长度为maxValue-minValue+1的数组计数，如下：
     * 扫描一遍原始数组，以当前值- minValue 作为下标，将该下标的计数器增1
     * 扫描一遍计数器数组，按顺序把值放回原数组
     *
     *
     * @param array 数组
     */
    public static void countingSort(int[] array) {
        // 默认最小值
        int min = array[0];
        // 默认最大值
        int max = array[0];
        // 遍历原数组得出最大值、最小值
        for (int i = 1; i < array.length; i++) {
            if (array[i] < min) {
                min = array[i];
            } else if (array[i] > max) {
                max = array[i];
            }
        }
        // 定义一个计数数组
        int[] count = new int[max - min + 1];
        // 遍历原数组统计数据出现次数，注意下标需要用当前值- minValue，因为数组长度为max - min + 1
        for (int v : array) {
            count[v - min]++;
        }
        // 移动下标
        int ix = 0;
        // 遍历计数数组回放原数组
        for (int i = 0; i < count.length; i++) {
            // 出现次数，对应值为i + min
            int cnt = count[i];
            // 根据出现次数循环多次放入原数组
            while (cnt-- > 0) {
                array[ix++] = i + min;
            }
        }
    }

    /**
     * 基数排序：构建有限的有序桶，把数据分类放入，更换分类指标重复上述步骤
     * 例如：12 8 33 16，构建0~9号桶
     * 第一步：低位作为指标分别放入2、3、6、8号桶，得出：12 33 16 8
     * 第二步：高一位作为指标分别放入0、1、3号桶，得出：8 12 16 33，注意不要破坏低位的顺序
     *
     * @param array 数组
     */
    public static void radixSort(int[] array) {
        // 基数数组，数字0~9，长度10即可
        int[] radix = new int[10];
        // 排序后临时存放数组
        int[] temp = new int[array.length];
        // 不确定总共有多少位，用于统计信息判断是否中断循环
        int cnt = 0;
        // 用于去除低位的除数，1 10 100 ...
        int m = 1;
        // 从低位到高位进行排序
        while (true) {
            // 重置桶中上次统计的数据
            for (int i = 0; i < radix.length; i++) {
                radix[i] = 0;
            }
            // 统计当前位对应值出现的次数
            for (int d : array) {
                // 去除当前位右边的低位，m为除数，每迭代一次*10
                int v = d / m;
                // 统计数组中含有指定位数的数量
                cnt = v > 1 ? cnt + 1 : cnt;
                // 当前位对应值出现次数计数
                radix[v % 10]++;
            }
            // 不存在指定位数的数，即没有更高的位了，中断循环
            if (cnt == 0) {
                break;
            }
            // 通过相邻的两个计数相加，得出基数对应的右边界（使用时需要减一）
            for (int i = 1; i < radix.length; i++) {
                radix[i] += radix[i - 1];
            }
            /*
            把原数组中数据按照当前位依次放入临时数组中
            1、相同位数据之间无序，不同位数据之间有序
            2、必须倒序遍历原数组，可以保证高位排序后低位有序，因为是从右边界开始放入，例如 45 35 36 46，从右边取低位较大
             */
            for (int i = array.length - 1; i >= 0; i--) {
                // 当前位对应值
                int ix = array[i] / m % 10;
                // --radix[ix]为右边界下标，从右边界开始放入
                temp[--radix[ix]] = array[i];
            }
            // 把部分有序的数据拷贝到原数组，进入高一位排序
            for (int i = 0; i < temp.length; i++) {
                array[i] = temp[i];
            }
            // 重置计数
            cnt = 0;
            // 高一位除数*10
            m *= 10;
        }
    }

    /**
     * 数组指定位置交换值（一个数异或同一个数两次，结果还是那个数）
     * 注意：下标i、j相同不能使用异或交换
     *
     * @param array 数组
     * @param i     交换位置i
     * @param j     交换位置j
     */
    private static void swap(int[] array, int i, int j) {
        if (i != j) {
            array[i] = array[i] ^ array[j];
            // 相当于array[i] ^ array[j] ^ array[j]
            array[j] = array[i] ^ array[j];
            // 相当于array[i] ^ array[j] ^ array[i]
            array[i] = array[i] ^ array[j];
        }
    }

    /**
     * 打印数组元素
     *
     * @param array    数组
     * @param sortType 排序类型
     */
    private static void display(int[] array, String sortType) {
        Arrays.stream(array).forEach(x -> System.out.print(x + " "));
        System.out.println(sortType);
    }

    /**
     * 通过反射调用指定排序方法
     *
     * @param sortType 排序方法
     */
    public static void sort(String sortType) {
        try {
            int[] array = new int[]{11, 56, 35, 62, 97, 21, 36, 33, 86, 81, 35, 8, 135, 235, 4567};
            Class<?> clz = Class.forName(NumberSort.class.getName());
            Method m = clz.getDeclaredMethod(sortType, int[].class);
            m.invoke(null, new Object[]{array});
            display(array, sortType);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        sort("bubbleSort");
        sort("quickSort");
        sort("threeWayQuickSort");
        sort("selectionSort");
        sort("heapSort");
        sort("straightInsertSort");
        sort("shellSort");
        sort("mergeSort");
        sort("bucketSort");
        sort("countingSort");
        sort("radixSort");
    }
}

```

## 选择准则

 影响排序的因素有很多，平均时间复杂度低的算法并不一定就是最优的。相反，有时平均时间复杂度高的算法可能更适合某些特殊情况。同时，选择算法时还得考虑它的可读性，以利于软件的维护。一般而言，需要考虑的因素有以下四点：

- 待排序的记录数目n的大小
- 记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小（复杂对象按局部属性排序）
- 关键字的结构及其分布情况
- 对排序稳定性的要求

根据待排序元素的个数n，分析如下：

- 当n较大，则应采用时间复杂度为${O(nlog_2n)}$的排序方法
  - 快速排序：是目前基于比较的内部排序中被认为最好的算法，当待排序的关键字是随机分布时，快速排序的平均时间最短
  - 堆排序 ：所需辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况
  - 归并排序：若需要排序稳定，且空间允许，可选用归并排序，但从单个记录起进行两两归并并不提倡，一般建议与直接插入排序（稳定）结合使用，先利用直接插入排序求得较长的有序子文件，再两两归并
- 当n较小，可采用直接插入或直接选择排序
  - 直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数
  - 简单选择排序：如果不要求稳定性，可选择直接选择排序
- 一般不使用或不直接使用传统的冒泡排序
- 基数排序：它是一种稳定的排序算法，但有一定的局限性
  - 关键字可分解
  - 记录的关键字位数较少，如果密集更好
  - 如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序

# 数组系列

## [350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)

### 描述

给定两个数组，编写一个函数来计算它们的交集。

**示例 1：**

```java
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
```

**示例 2:**

```java
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```

**说明：**

- 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致
- 我们可以不考虑输出结果的顺序

**进阶：**

- 如果给定的数组已经排好序呢？你将如何优化你的算法？（实践三，没有排序开销，时间复杂度更低）
- 如果 nums1 的大小比 nums2 小很多，哪种方法更优？（实践二，为较小的数组构建哈希表）
- 如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？（实践二，没有排序不需要加载nums2全部内容，只需要为nums1构建HashMap结构）

### 实践一

计算每个元素在各个数组中出现的次数，以出现次数最小值作为实际输出次数，代码如下：

```java
public static int[] intersect(int[] nums1, int[] nums2) {
    // 构建并存储数组nums1元素出现次数
    Map<Integer, Integer> map1 = new HashMap<>(nums1.length);
    for (int value : nums1) {
        if (map1.containsKey(value)) {
            map1.put(value, map1.get(value) + 1);
        } else {
            map1.put(value, 1);
        }
    }
    // 构建并存储数组nums2元素出现次数
    Map<Integer, Integer> map2 = new HashMap<>(nums2.length);
    for (int value : nums2) {
        if (map2.containsKey(value)) {
            map2.put(value, map2.get(value) + 1);
        } else {
            map2.put(value, 1);
        }
    }
    // 交集元素个数
    int n = 0;
    // 循环任意一个HashMap结构，删除在另一个数组不存在的元素，并更新元素出现次数为两个数组中出现次数的最小值
    for (Iterator<Map.Entry<Integer, Integer>> it = map1.entrySet().iterator(); it.hasNext(); ) {
        Map.Entry<Integer, Integer> item = it.next();
        if (map2.containsKey(item.getKey())) {
            if (item.getValue() > map2.get(item.getKey())) {
                map1.put(item.getKey(), map2.get(item.getKey()));
            }
            n += map1.get(item.getKey());
        } else {
            it.remove();
        }
    }
    // 构建交集元素数组
    int[] result = new int[n];
    int ix = 0;
    // 循环交集元素次数的HashMap构建交集数组
    for (Map.Entry<Integer, Integer> entry : map1.entrySet()) {
        for (int i = 0; i < entry.getValue(); i++) {
            result[ix++] = entry.getKey();
        }
    }
    return result;
}
```

### 实践二

计算数组中元素出现次数构建了两个HashMap，能否减少空间占用？

可以先构建一个HashMap存储小数组中元素的出现次数，然后遍历另一个数组，判断是否存在HashMap中，若存在保存在结果集中，并扣减出现次数，直到扣减为0后从HashMap中删除。

为什么为构建小数组构建HashMap？大概率空间占用小，不排除大数组中存在大量重复元素

```java
public static int[] intersect2(int[] nums1, int[] nums2) {
    // 优先为小数组构建HashMap结构存储元素出现次数
    if (nums1.length > nums2.length) {
        return intersect2(nums2, nums1);
    }
    // 构建并存储元素出现次数
    Map<Integer, Integer> map = new HashMap<>(nums1.length);
    for (Integer v : nums1) {
        int count = map.getOrDefault(v, 0) + 1;
        map.put(v, count);
    }
    // 交集数组中当前存储下标
    int ix = 0;
    for (Integer v : nums2) {
        // 判断另一个数组中元素是否存在已构建的HashMap中，不要使用containsKey(),直接获取value，下面需要用到
        int count = map.getOrDefault(v, 0);
        if (count > 0) {
            // 存在加入交集数组（使用nums1存储）
            nums1[ix++] = v;
            // 扣减存在次数
            count--;
            // 更新存在次数，为0就可以直接删除该key（删除是为了尽快释放空间占用）
            if (count == 0) {
                map.remove(v);
            } else {
                map.put(v, count);
            }
        }
    }
    // 数组截取返回实际交集元素
    return Arrays.copyOfRange(nums1, 0, ix);
}
```

**复杂度分析**

- 时间复杂度：O(m+n)，其中 m 和 n 分别是两个数组的长度。需要遍历两个数组并对哈希表进行操作，哈希表操作的时间复杂度是 O(1)，因此总时间复杂度与两个数组的长度和呈线性关系。
- 空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个数组的长度。对较短的数组进行哈希表的操作，哈希表的大小不会超过较短的数组的长度。交集数组长度也小于较短数组的长度

### 实践三

如果两个数组是有序的，则可以便捷地计算两个数组的交集。

首先对两个数组进行排序，然后使用两个指针遍历两个数组。

初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。

```java
 public static int[] intersect3(int[] nums1, int[] nums2) {
     Arrays.sort(nums1);
     Arrays.sort(nums2);
     int length1 = nums1.length;
     int length2 = nums2.length;
     int a = 0;
     int b = 0;
     int[] r = new int[Math.min(length1, length2)];
     int ix = 0;
     while (a < length1 && b < length2) {
         if (nums1[a] == nums2[b]) {
             r[ix++] = nums1[a];
             a++;
             b++;
         } else if (nums1[a] > nums2[b]) {
             b++;
         } else {
             a++;
         }
     }
     return Arrays.copyOfRange(r, 0, ix);
 }
```

**复杂度分析**

- 时间复杂度：O(mlogm+nlogn)，其中 m 和 n 分别是两个数组的长度。对两个数组进行排序的时间复杂度是 O(mlogm+nlogn)，遍历两个数组的时间复杂度是 O(m+n)，因此总时间复杂度是 O(mlogm+nlogn)

- 空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个数组的长度。为返回值创建一个数组 r，其长度为较短的数组的长度。未考虑排序空间开销

# 栈和队列系列

## 设计一个有getMin功能的栈*

```java
/**
 * 设计一个有getMin功能的栈
 * 1、pop、push、getMin操作时间复杂度都是O(1)
 * 2、设计的栈类型可以使用现成的栈结构
 */
public class MinStack {

    /**
     * 正常的数据栈
     */
    private Stack<Integer> stackData;
    /**
     * 最小数据栈
     */
    private Stack<Integer> stackMin;

    public MinStack() {
        stackData = new Stack<>();
        stackMin = new Stack<>();
    }

    /**
     * 放入数据栈（每次遇到更小的元素放入最小栈）
     * @param newNum 新数据
     */
    public void push(int newNum) {
        // 最小栈为空直接放入
        if (stackMin.isEmpty()) {
            stackMin.push(newNum);
            // 不为空的时候，只有新加入元素小于或等于栈顶元素时放入
        } else if (newNum <= this.getMin()) {
            stackMin.push(newNum);
        }
        // 正常放入数据栈
        stackData.push(newNum);
    }

    /**
     * 获取当前栈中最小值（后放入的较大元素虽然不进最小栈，但栈元素后进先出，数据栈不为空时，最小栈不为空）
     * @return 最小值
     */
    public Integer getMin() {
        if (stackMin.isEmpty()) {
            throw new RuntimeException("stack is empty");
        }
        return stackMin.peek();
    }

    /**
     * 弹出栈
     * @return 栈顶值
     */
    public Integer pop() {
        if (stackData.isEmpty()) {
            throw new RuntimeException("stack is empty");
        }
        // 正常弹出
        Integer v = stackData.pop();
        // 当弹出值为最小值时，最小栈跟着弹出
        if (v.equals(getMin())) {
            stackMin.pop();
        }
        return v;
    }

    public static void main(String[] args) {
        MinStack minStack = new MinStack();
        minStack.push(3);
        minStack.push(4);
        minStack.push(9);
        System.out.println(minStack.getMin());
        System.out.println(minStack.pop());
        System.out.println(minStack.getMin());
    }
}
```

## 两个栈组成的队列**

```java
/**
 * 由两个栈组成队列，支持队列的基本操作(add、poll、peek)
 */
public class TwoStackQueue {
    /**
     * 压入栈
     */
    private Stack<Integer> stackPush;
    /**
     * 弹出栈
     */
    private Stack<Integer> stackPop;

    public TwoStackQueue() {
        stackPush = new Stack<>();
        stackPop = new Stack<>();
    }

    public void add(int newNum) {
        stackPush.add(newNum);
    }

    public Integer pop() {
        if (stackPop.isEmpty() && stackPush.isEmpty()) {
            throw new RuntimeException("Queue is empty");
        } else if (stackPop.isEmpty()) {
            // 压入栈不为空，一次性全部弹出并压入弹出栈
            while (!stackPush.isEmpty()) {
                stackPop.push(stackPush.pop());
            }
        }
        return stackPop.pop();
    }

    public Integer peek() {
        if (stackPop.isEmpty() && stackPush.isEmpty()) {
            throw new RuntimeException("Queue is empty");
        } else if (stackPop.isEmpty()) {
            while (!stackPush.isEmpty()) {
                stackPop.push(stackPush.pop());
            }
        }
        return stackPop.peek();
    }

    public static void main(String[] args) {
        TwoStackQueue stackQueue = new TwoStackQueue();
        stackQueue.add(1);
        stackQueue.add(2);
        System.out.println(stackQueue.pop());
        stackQueue.add(3);
        stackQueue.add(4);
        System.out.println(stackQueue.pop());
    }
}
```

## 使用递归函数和栈操作逆序一个栈**

```java
/**
 * 栈反转，即反向从栈顶元素开始压入，且栈为空
 * 根据上述前提，栈为空是终止条件，且栈为空时应该拿到的是栈顶元素，利用递归不断缩小栈即可，缩小栈也需要用到队规，所以需要用两个递归函数
 */
public class ReverseStack {

    /**
     * 弹出栈最后一个值并返回
     * @param stack 栈
     * @return 最后一个值
     */
    public Integer getAndRemoveLastElement(Stack<Integer> stack) {
        int v = stack.pop();
        if (stack.isEmpty()) {
            return v;
        } else {
            // 递归获取栈最后一个值
            int last = getAndRemoveLastElement(stack);
            // 把每次递归最后一个值的上一个值重新压入栈
            stack.push(v);
            return last;
        }
    }

    /**
     * 反转栈
     * @param stack 数字栈
     */
    public void reverve(Stack<Integer> stack) {
        if (stack == null || stack.isEmpty()) {
            return;
        }
        // 弹出栈最后一个值并返回
        Integer last = getAndRemoveLastElement(stack);
        // 递归弹出栈最后一个值，最后就拿到栈顶的元素
        reverve(stack);
        // 递归到最后反向从栈顶元素依次压入
        stack.push(last);
    }

    public static void main(String[] args) {
        Stack<Integer> stackData = new Stack<>();
        stackData.push(1);
        stackData.push(2);
        stackData.push(3);
        stackData.push(4);
        stackData.push(5);
        new ReverseStack().reverve(stackData);
        while (!stackData.isEmpty()) {
            System.out.println(stackData.pop());
        }
    }
}
```

## 猫狗队列*

```java
/**
 * 猫狗队列，要求如下：
 * 1、支持add方法，将cat或者dog类的实例放入队列中
 * 2、支持pollAll方法，将队列中所有实例按照队列的先后顺序依次弹出
 * 3、支持pollDog方法，将队列中dog类实例按照队列的先后顺序依次弹出
 * 4、支持pollCat方法，将队列中cat类实例按照队列的先后顺序依次弹出
 * 5、支持isEmpty方法，判断队列中是否还存在cat或者dog实例
 * 6、支持isCatEmpty方法，判断队列中是否还存在cat实例
 * 7、支持isDogEmpty方法，判断队列中是否还存在dog实例
 */
public class CatDogQueue {

    static class Pet {
        private String type;

        public Pet(String type) {
            this.type = type;
        }

        public String getType() {
            return type;
        }
    }

    static class Cat extends Pet {

        public Cat() {
            super("Cat");
        }
    }

    static class Dog extends Pet {

        public Dog() {
            super("Dog");
        }
    }

    /**
     * 猫狗实例封装类，用于记录实例进入队列的先后顺序（此处使用简单计数）
     */
    static class PetEnterQueue {
        private long count;
        private Pet pet;

        public PetEnterQueue(Pet pet, long count) {
            this.pet = pet;
            this.count = count;
        }
    }

    /**
     * 存放cat实例
     */
    private Queue<PetEnterQueue> catQueue;
    /**
     * 存放dog实例
     */
    private Queue<PetEnterQueue> dogQueue;
    /**
     * 计数用于计算实例进入队列顺序
     */
    private long count;

    public CatAndDogQueue() {
        this.catQueue = new LinkedList<>();
        this.dogQueue = new LinkedList<>();
    }

    /**
     * 根据实例类型进入不同的队列
     *
     * @param pet 猫或狗实例
     */
    public void add(Pet pet) {
        if ("Dog".equals(pet.getType())) {
            dogQueue.add(new PetEnterQueue(pet, count++));
        } else if ("Cat".equals(pet.getType())) {
            catQueue.add(new PetEnterQueue(pet, count++));
        } else {
            throw new RuntimeException("err,not dog or cat");
        }
    }

    /**
     * 从队列中弹出猫或够实例
     *
     * @return Pet
     */
    public Pet pollAll() {
        // 同时存在猫或狗实例，按照进入先后顺序弹出，记住count计数
        if (!catQueue.isEmpty() && !dogQueue.isEmpty()) {
            if (catQueue.peek().count < dogQueue.peek().count) {
                return catQueue.poll().pet;
            } else {
                return dogQueue.poll().pet;
            }
        } else if (!catQueue.isEmpty()) {
            return catQueue.poll().pet;
        } else if (!dogQueue.isEmpty()) {
            return dogQueue.poll().pet;
        } else {
            throw new RuntimeException("queue is empty");
        }
    }

    public Dog pollDog() {
        if (this.dogQueue.isEmpty()) {
            throw new RuntimeException("dog queue is empty");
        }
        return (Dog) this.dogQueue.poll().pet;
    }

    public Cat pollCat() {
        if (catQueue.isEmpty()) {
            throw new RuntimeException("dog queue is empty");
        }
        return (Cat) catQueue.poll().pet;
    }

    public boolean isEmpty() {
        return catQueue.isEmpty() && dogQueue.isEmpty();
    }

    public boolean isDogEmpty() {
        return dogQueue.isEmpty();
    }

    public boolean isCatEmpty() {
        return catQueue.isEmpty();
    }

    public static void main(String[] args) {
        CatDogQueue dogCatQueue = new CatDogQueue();

        Pet dog1 = new Dog();
        Pet cat1 = new Cat();
        Pet dog2 = new Dog();
        Pet cat2 = new Cat();
        Pet dog3 = new Dog();
        Pet cat3 = new Cat();

        dogCatQueue.add(dog1);
        dogCatQueue.add(cat1);
        dogCatQueue.add(dog2);
        dogCatQueue.add(cat2);
        dogCatQueue.add(dog3);
        dogCatQueue.add(cat3);

        dogCatQueue.add(dog1);
        dogCatQueue.add(cat1);
        dogCatQueue.add(dog2);
        dogCatQueue.add(cat2);
        dogCatQueue.add(dog3);
        dogCatQueue.add(cat3);
        while (!dogCatQueue.isDogEmpty()) {
            System.out.println(dogCatQueue.pollDog().getType());
        }
    }
}
```

## 用一个栈实现另一个栈的排序*

```java
/**
 * 用一个栈实现另一个栈的排序，实现栈顶到栈底从大到小排序，且只能申请一个栈，不能申请额外的数据结构
 */
public class TwoStackSort {

    /**
     * 用一个栈实现另一个栈的排序
     *
     * @param stackData 待排序栈
     */
    public static void sort(Stack<Integer> stackData) {
        // 辅助栈
        Stack<Integer> stackHelp = new Stack<>();
        // 遍历待排序栈，把数据栈顶到栈底从小到大排序放入辅助栈
        while (!stackData.isEmpty()) {
            // 弹出栈顶元素
            int v1 = stackData.pop();
            // 把辅助栈中比v1小的值都弹出放入原栈中，保存大值总是在下面
            while (!stackHelp.isEmpty() && v1 > stackHelp.peek()) {
                stackData.push(stackHelp.pop());
            }
            // 把当前值放入辅助栈
            stackHelp.push(v1);
        }
        // 由于辅助栈数据顺序和要求相反，依次弹出放入原数据栈即可
        while (!stackHelp.isEmpty()) {
            stackData.push(stackHelp.pop());
        }
    }

    public static void main(String[] args) {
        Stack<Integer> stackData = new Stack<>();
        stackData.push(6);
        stackData.push(3);
        stackData.push(5);
        stackData.push(1);
        stackData.push(2);
        TwoStackSort.sort(stackData);
        while (!stackData.isEmpty()) {
            System.out.println(stackData.pop());
        }
    }
}
```

## 用栈求解汉诺塔问题***

## 生成窗口最大值数组**

```java
/**
 * 生成窗口最大值数组，有一个整形数组arr和一个大小为w的窗口，从数组的最左边滑到最右边，每次向右滑一个位置
 */
public class ArrayMaxWindow {

    /**
     * 生成窗口最大值数组
     * 时间复杂度O(N*W) N为数组长度，W为窗口大小
     *
     * @param data 数组
     * @param w    窗口大小
     * @return 最大窗口数组
     */
    public static int[] windowMax1(int[] data, int w) {
        if (data == null || data.length < w || w < 1) {
            return null;
        }
        int[] result = new int[data.length - w + 1];
        int start = 0;
        int end = w - 1;
        int ix = 0;
        while (end < data.length) {
            for (int i = start; i <= end; i++) {
                if (data[i] > result[ix]) {
                    result[ix] = data[i];
                }
            }
            ix++;
            start++;
            end++;
        }
        return result;
    }

    /**
     * 生成窗口最大值数组
     * 时间复杂度O(N) N为数组长度
     *
     * @param data 数组
     * @param w    窗口大小
     * @return 最大窗口数组
     */
    public static int[] windowMax2(int[] data, int w) {
        if (data == null || data.length < w || w < 1) {
            return null;
        }
        // 构建双端队列
        LinkedList<Integer> qmax = new LinkedList<>();
        // 最大窗口数组
        int[] result = new int[data.length - w + 1];
        // 最大窗口当前下标
        int index = 0;
        for (int i = 0; i < data.length; i++) {
            // 按照从大到小依次放入双端队列(仅存放值对应下标)，遇到队列末尾值较小依次弹出
            while (!qmax.isEmpty() && data[qmax.peekLast()] <= data[i]) {
                qmax.pollLast();
            }
            // 把数组下标放入队列（下次循环执行弹出规则，弹出小值的下标）
            qmax.addLast(i);
            // 删除过期下标，即首个下标与当前下标不能超过窗口长度
            if (qmax.peekFirst() == i - w) {
                qmax.pollFirst();
            }
            // 从下标w-1开始即可计算窗口最大值
            if (i >= w - 1) {
                result[index++] = data[qmax.peekFirst()];
            }
        }
        return result;
    }

    public static void main(String[] args) {
        int[] data = {4, 3, 15, 4, 3, 3, 6, 7, 9, 8, 2};
        int[] result = windowMax1(data, 3);
        Arrays.stream(result).forEach(x -> System.out.print(x + " "));
        System.out.println();
        int[] result2 = windowMax2(data, 3);
        Arrays.stream(result2).forEach(x -> System.out.print(x + " "));
    }
}
```



# 链表系列

## 有序双端链表

```java
/**
 * 有序双向链表
 */
public class SortedLinkedList {

    static class Node {
        private int value;
        private Node pre;
        private Node next;

        public Node(int value) {
            this.value = value;
        }
    }

    private Node head;

    private Node tail;

    /**
     * 插入节点
     *
     * @param v 插入数据
     */
    public void insert(int v) {
        // 构建节点
        Node node = new Node(v);
        // 首个大于或等于v的节点的前一个节点，即待插入位置前一个节点
        Node pre = null;
        // 首个大于或等于v的节点，即待插入位置后一个节点
        Node cur = head;
        // 寻找第一个大于或等于v的节点
        while (cur != null && cur.value < node.value) {
            pre = cur;
            cur = cur.next;
        }
        // 若待插入位置前一个节点为空，说明插入在头部，不需要建立向前的双向关系，重置头节点即可
        if (pre == null) {
            head = node;
        } else {
            // 若待插入位置前一个节点不为空，建立与前一个节点双向关系
            pre.next = node;
            node.pre = pre;
        }
        // 待插入位置后一个节点为空，说明插入在尾部，不需要建立后向关系，重置尾节点即可
        if (cur == null) {
            tail = node;
        } else {
            // 待插入位置后一个节点不为空，建立与后一个节点双向关系
            cur.pre = node;
            node.next = cur;
        }
    }

    /**
     * 删除指定值的节点
     *
     * @param v 待删除值
     */
    public void delete(int v) {
        // 从头结点开始查找删除起始节点
        Node cur = head;
        Node start = null;
        Node end = null;
        // 头结点开始直到首个大于该值的节点结束
        while (cur != null && cur.value <= v) {
            if (cur.value == v) {
                start = start == null ? cur : start;
                end = cur;
            }
            cur = cur.next;
        }
        // 若存在待删除的节点，起始节点一定不为空
        if (start != null) {
            // 如果从头部开始删除，重置头节点为结束位置的下一个节点
            if (start == head) {
                head = end.next;
            } else {
                // 如果不是从头节点开始删除，先建立前一个节点与结束位置下一个节点的单向关系(因为下一个节点有可能为空)
                start.pre.next = end.next;
            }
            // 如果末尾节点也被删除，重置尾结点为起始节点的前一个节点
            if (end == tail) {
                tail = start.pre;
            } else {
                // 若不删除末尾节点，建立结束位置下一个节点与起始位置上一个节点的单向关系
                end.next.pre = start.pre;
            }
        }
    }

    public static void main(String[] args) {
        SortedLinkedList sortedLinkdedList = new SortedLinkedList();
        sortedLinkdedList.insert(2);
        sortedLinkdedList.insert(1);
        sortedLinkdedList.insert(3);
        sortedLinkdedList.insert(6);
        sortedLinkdedList.insert(6);
        sortedLinkdedList.insert(2);
        sortedLinkdedList.insert(5);
        sortedLinkdedList.delete(6);
        Node node = sortedLinkdedList.head;
        while (node != null) {
            System.out.println(node.value + " pre：" + (node.pre == null ? "" : node.pre.value));
            node = node.next;
        }
    }
}
```

# 字符串系列

## 互为变形词

```java
/**
 * 给定两个字符串str1和str2，如果str1和str2中出现的字符种类一样且每种字符出现的次数也一样，那么str1和str2互为变形词。
 * 例如：
 * str1 = "123"，str2 = "231"，返回true
 * str1 = "123"，str2 = "2331"，返回false
 */
public class StringAnagram {

    /**
     * 校验字符串str1和str2是否互为变形词
     * 时间复杂度：O(N)   空间复杂度：O(M)，N为字符串长度，M为字符种类
     *
     * @param str1 字符串1
     * @param str2 字符串2
     * @return 是否互为变形词
     */
    public static boolean isAnagram1(String str1, String str2) {
        // 任意字符串为空或者两者长度不一致，非互为变形词，直接返回false
        if (str1 == null || str2 == null || str1.length() != str2.length()) {
            return false;
        }
        // 假设出现字符的编码值在0~255之间，常用的英文以及符号都在这个范围内
        int[] array = new int[256];
        // 第一个字符串每个字符对应下标加1
        for (char c : str1.toCharArray()) {
            array[c]++;
        }
        // 第二个字符串每个字符对应下标减1
        for (char c : str2.toCharArray()) {
            // 减之后小于0，直接返回false。因为两个字符串长度一样，如果出现频次不同，总有一个下标为减1后为负数
            if (array[c]-- == 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * 校验字符串str1和str2是否互为变形词
     * 时间复杂度：O(N)   空间复杂度：O(N)，N为字符串长度
     *
     * @param str1 字符串1
     * @param str2 字符串2
     * @return 是否互为变形词
     */
    public static boolean isAnagram2(String str1, String str2) {
        // 任意字符串为空或者两者长度不一致，非互为变形词，直接返回false
        if (str1 == null || str2 == null || str1.length() != str2.length()) {
            return false;
        }
        int len = str1.length();
        // 临时存放字符串对应字符
        List<Character> list = new ArrayList<>(len);
        for (int i = 0; i < len; i++) {
            process(str1.charAt(i), list);
            process(str2.charAt(i), list);
        }
        return list.isEmpty();
    }

    /**
     * 不存在加入，存在去除。如果互为变形词，最终集合为空
     *
     * @param c    字符
     * @param list ArrayList
     */
    private static void process(Character c, List<Character> list) {
        if (list.contains(c)) {
            list.remove(c);
        } else {
            list.add(c);
        }
    }

    public static void main(String[] args) {
        String str1 = "123";
        String str2 = "231";
        System.out.println(isAnagram1(str1, str2));
        System.out.println(isAnagram2(str1, str2));
    }
}
```

## 数字子串求和

```java
/**
 * 给定一个字符串str，求其中全部数字串所代表的数字之和
 * 要求：
 * 1. 忽略小数点字符，例如“A1.3”，其中包含两个数字1和3
 * 2. 如果紧贴数字子串的左侧出现字符“-”，当连续出现的数量为奇数时，则数字视为负，连续出现的数量为偶数时，则数字视为正，
 * 例如“A-1BC--12”，其中包含数字-1和12
 */
public class SubStringSum {

    /**
     * 求其中全部数字串所代表的数字之和
     * 时间复杂度：O(N)   空间复杂度：O(1)，N为字符串长度
     *
     * @param str 字符串
     * @return 数字之和
     */
    public static int process(String str) {
        if (str == null || str.length() == 0) {
            return 0;
        }
        int res = 0;
        int num = 0;
        int fact = 1;
        int cur;
        char pre = 0;
        for (char c : str.toCharArray()) {
            // 数字字符减去字符0等于数字本身
            cur = c - '0';
            if (cur >= 0 && cur <= 9) {
                // 对于连续数字，上次结果乘以10，再加上本次数字即可
                num = num * 10 + cur * fact;
            } else {
                // 连续数字中断，累加到结果中
                res += num;
                // 上次数字结果累加后归0
                num = 0;
                // 当前字符为-，需要考虑前一个字符是否为-
                if (c == '-') {
                    // 前一个字符为-，取反即可
                    if (pre == '-') {
                        fact *= -1;
                    } else {
                        fact = -1;
                    }
                } else {
                    fact = 1;
                }
            }
            pre = c;
        }
        return res + num;
    }

    public static void main(String[] args) {
        System.out.println(process("A-1BC--12"));
        System.out.println(process("A1CD2E33"));
        System.out.println(process("A-1B--2C--D6E"));
        System.out.println(process("-1-2"));

    }
}
```

## 去掉字符串中连续出现K个0的子串

```java
/**
 * 给定一个字符串str和一个整数k，如果str中刚好有连续的k个‘0’字符出现时，把k个连续的‘0’字符删除，返回处理后的字符串
 * 例如：
 * str = “A00B”，k = 2，返回 “AB”。
 * str = “A0000B000”，k = 3，返回 “A0000B”
 */
public class RemoveKZeros {

    /**
     * 删除k个连续的‘0’字符
     * 时间复杂度：O(N)   空间复杂度：O(1)，N为字符串长度
     *
     * @param str 字符串
     * @param k   连续k个0
     * @return 删除连续k个0后字符串
     */
    public static String process(String str, int k) {
        if (str == null || str.length() == 0 || k < 1) {
            return str;
        }
        char[] chars = str.toCharArray();
        // 连续k个0起始下标
        int start = -1;
        // 连续0个数
        int count = 0;
        // 数组当前下标
        int ix = 0;
        for (char c : chars) {
            if (c == '0') {
                // 记录起始下标
                start = start == -1 ? ix : start;
                count++;
            } else {
                // 当不再是0，看看之前是否连续k个0，如是均置为数字0
                if (count == k) {
                    while (count-- > 0) {
                        chars[start++] = 0;
                    }
                }
                start = -1;
                count = 0;
            }
            ix++;
        }
        // 若结尾是连续k个0，均置为数字0
        if (count == k) {
            while (count-- > 0) {
                chars[start++] = 0;
            }
        }
        return String.valueOf(chars).replaceAll("[\u0000]", "");
    }

    public static void main(String[] args) {
        System.out.println(process("A00B", 2));
        System.out.println(process("A0000B000", 3));
    }
}
```

## 判断字符串str是否含有子串match

```java
/**
 * 给定两个字符串str和match，长度分为为N和M。判断字符串str是否含有子串match，若存在返回match在str中开始位置，反之返回-1
 * 例如：
 * str="acbc"，match="bc"，返回2
 * str="acbc"，match="bcc"，返回-1
 */
public class StringMatch {

    /**
     * 普通解法，从左向右依次从str第i个字符出发，判断是否匹配
     * 时间复杂度：O(N*M)   M、N为两个字符串长度
     *
     * @param str   字符串str
     * @param match 子字符串match
     * @return 子字符串起始位置
     */
    public static int match(String str, String match) {
        if (str == null || match == null || str.length() < 1 || str.length() < match.length()) {
            return -1;
        }
        boolean flag = true;
        char[] chars1 = str.toCharArray();
        char[] chars2 = match.toCharArray();
        // 从第i个字符出发
        for (int i = 0; i < chars1.length; i++) {
            // 判断是否与match字符串匹配
            for (int j = 0; j < chars2.length; j++) {
                // 此处需要注意i+j数组越界，发现不匹配中断进入下一次匹配
                if (i + j > chars1.length - 1 || chars1[i + j] != chars2[j]) {
                    flag = false;
                    break;
                }
            }
            // 匹配上返回当前下标i即可
            if (flag) {
                return i;
            } else {
                // 不匹配需要把重置flag标志
                flag = true;
            }
        }
        return -1;
    }

    /**
     * 最优解法KMP，采用数组部分匹配表(Partial Match Table)，不进行指针回溯
     * 时间复杂度：O(N)  N为str字符串长度 空间复杂度：O(M)，M为匹配子字符串长度
     * http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html
     *
     * @param str   字符串str
     * @param match 子字符串match
     * @return 子字符串起始位置
     */
    public static int match2(String str, String match) {
        if (str == null || match == null || str.length() < 1 || str.length() < match.length()) {
            return -1;
        }
        char[] chars1 = str.toCharArray();
        char[] chars2 = match.toCharArray();
        // 获取匹配子串部分匹配表PMT
        int[] next = getNextArray(chars2);
        // 定义两个指针
        int i = 0, j = 0;
        // 两个数组都从下标0开始
        while (i < chars1.length && j < chars2.length) {
            // 如果两个下标值一样，右移比较下一位
            if (chars1[i] == chars2[j]) {
                i++;
                j++;
                // 如果两个下标值不一样，在部分匹配表PMT中查询匹配串当前下标前字符串的最大匹配长度，即头尾部分最大相同长度
            } else if (next[j] == -1) {
                // 如果最大匹配长度为-1，表示主串和匹配串首位都不一致，主串右移从下一位开始即可
                i++;
            } else {
                // 如果最大匹配长度不为-1，表示主串和匹配串已经有匹配上的部分，
                // 此时需要看此部分的首尾相同长度，从匹配串此部分最大相同前缀的下一位重新比较即可
                j = next[j];
            }
        }
        // 判断匹配串的下标是否已经到尾部，到底尾部说明完全匹配上了，用主串下标减去匹配串长度即可
        return j == chars2.length ? i - j : -1;
    }

    /**
     * 计算每个下标前字符串最大前缀和后缀匹配长度
     * 例如：
     * "ABC"的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0
     *
     * @param ms 字符数组
     * @return 最大前缀和后缀匹配长度
     */
    public static int[] getNextArray(char[] ms) {
        if (ms.length == 1) {
            return new int[]{-1};
        }
        // 记录当前下标之前字符串的最大前缀和后缀匹配长度
        int[] next = new int[ms.length];
        // 下标0前没有字符，最大匹配长度记为-1
        next[0] = -1;
        // 下标1后只有一个字符，即没有前缀和后缀，最大匹配长度记为0
        next[1] = 0;
        // 从下标2，即第三个元素开始，因为记录是之前字符串最大匹配长度
        int pos = 2;
        // 前后缀最大匹配字符数，默认0
        int cn = 0;
        // 从pos=2即第三位开始，计算pos前字符串前缀和后缀最大匹配长度
        while (pos < ms.length) {
            /*
              cn表示最大匹配字符数，下标从0开始，ms[cn]即最大匹配前缀的下一位
              判断当前末位字符，即上一次最大匹配字符后缀的下一位，与ms[cn]是否一致，如果一致，上一次的最大匹配长度加1即可
             */
            if (ms[pos - 1] == ms[cn]) {
                // 记录最大匹配长度，然后指针向右移动
                next[pos++] = ++cn;
                // 如果最大前缀和后缀的下一位不一致，向左找上一个最大前缀
            } else if (cn > 0) {
                // cn>0表示存在最大匹配前缀
                cn = next[cn];
            } else {
                // cn=0表示已经找到最左边，还是没有发现一样元素，因此最大匹配长度记为0
                next[pos++] = 0;
            }
        }
        return next;
    }

    public static void main(String[] args) {
        System.out.println(match("acbc", "bc"));
        System.out.println(match("acbc", "bcc"));
        System.out.println(match2("abcdab abcdabcdabde", "abcdabd"));
        Arrays.stream(getNextArray2("abcabcaee".toCharArray())).forEach(System.out::print);
    }
}
```

## 判断两个字符串是否互为旋转词

```java
/**
 * 判断两个字符串是否互为旋转词
 * 如果一个字符串为str，把字符串str前面任意的部分挪到后面形成的字符串叫作str的旋转词
 * 比如str=“12345”，str的旋转词有“12345”，“23451”，“34512”，“45123”，“51234”
 */
public class RotatingWords {

    /**
     * 判断两个字符串是否互为旋转词
     * 时间复杂度：O(N)   N为字符串长度
     *
     * @param str1 字符串1
     * @param str2 字符串2
     * @return true/false
     */
    public static boolean verify(String str1, String str2) {
        if (str1 == null || str2 == null || str1.length() != str2.length()) {
            return false;
        }
        // 旋转词是把任意头部元素放到尾部，把旋转后的词叠加肯定含有旋转前的词
        String str3 = str2 + str2;
        // 使用KMP算法，时间复杂度O(N)
        return StringMatch.match2(str3, str1) != -1;
    }


    public static void main(String[] args) {
        System.out.println(verify("12345", "12345"));
        System.out.println(verify("12345", "23451"));
        System.out.println(verify("12345", "34512"));
        System.out.println(verify("12345", "45123"));
        System.out.println(verify("12345", "51234"));
        System.out.println(verify("12345", "15234"));
    }
}
```

## 返回str所代表的整数值

```java
/**
 * 给定一个字符串str，如果str符合日常书写的整数形式，并且属于32位整数的范围，返回str所代表的整数值，否则返回0
 * 例如：str="123"，返回123
 */
public class StringToInt {

    /**
     * 字符串转化为整数
     * 时间复杂度：O(N) N为字符串长度
     *
     * @param str 字符串
     * @return int
     */
    public static int process(String str) {
        int num = 0;
        if (str == null || str.length() == 0 || str.charAt(0) == '0') {
            return num;
        }
        char[] chars = str.toCharArray();
        // 以-开头，从下标1开始
        int ix = chars[0] == '-' ? 1 : 0;
        // 去除最低位的最小值（为什么取最小值？因为最小值的绝对值比最大值大1，用最大值-2147483648无法转换异常）
        int min1 = Integer.MIN_VALUE / 10;
        // 最小值最低位的值
        int min2 = Integer.MIN_VALUE % 10;
        while (ix < chars.length) {
            // 转换为负值
            int v = '0' - chars[ix];
            // 排除符号位后首位为0不合法
            if (num == 0 && v == 0) {
                return 0;
            }
            // 不在0~9之间
            if (-v < 0 || -v > 9) {
                return 0;
            }
            // 累加之和已经小于去除末尾的最小值-214748364，这时再*10就超出范围了
            if (num < min1) {
                return 0;
            }
            // 累加之和已经等于去除末尾的最小值-214748364，与末尾最小值-8进行比较，小于就超范围了
            if (num == min1 && v < min2) {
                return 0;
            }
            num = num * 10 + v;
            ix++;
        }
        // 非负数但求和等于最小值，此时转换为正数超出范围
        if (num == Integer.MIN_VALUE && chars[0] != '-') {
            return 0;
        }
        // 转换符号位
        return chars[0] == '-' ? num : -num;
    }

    public static void main(String[] args) {
        System.out.println(process("123"));
        System.out.println(process("023"));
        System.out.println(process("A23"));
        System.out.println(process("-01"));
        System.out.println(process("2147483647"));
        System.out.println(process("2147483648"));
        System.out.println(process("-2147483648"));
        System.out.println(process("-2147483649"));
        System.out.println(process("-123"));
    }
}
```

## 替换字符串中连续出现的指定字符串

```java
/**
 * 替换字符串中连续出现的指定字符串，给定三个字符串str，from，to，把str中所有from的子字符串替换为to字符串，
 * 对连续出现from的部分要求只替换成一个to字符串
 * 举例：
 * str="123abc",from="abc",to="4567",return "1234567";
 * str="123",from="abc",to="456",return "123";
 * str="123abcabc",from="abc",to="X",return "123X";
 */
public class StringReplace {

    /**
     * 替换字符串中连续出现的指定字符串
     * 时间复杂度：O(N)   空间复杂度：O(N)，N为字符串长度
     *
     * @param str  原字符串
     * @param from 替换子串
     * @param to   替换后子串
     * @return 替换后主串
     */
    public static String process(String str, String from, String to) {
        if (str == null || from == null || to == null || str.length() < from.length() || from.length() == 0) {
            return str;
        }
        int cnt = 0;
        char[] chars1 = str.toCharArray();
        char[] chars2 = from.toCharArray();
        for (int i = 0; i < chars1.length; i++) {
            // 与from子串匹配计数
            if (chars1[i] == chars2[cnt++]) {
                // 完全匹配上from子串替换为0
                if (cnt == chars2.length) {
                    while (cnt > 0) {
                        cnt--;
                        // 设置为空字符
                        chars1[i - cnt] = 0;
                    }
                }
            } else {
                cnt = 0;
            }
        }
        // 把连续出现的0替换为字符串to
        StringBuilder builder = new StringBuilder();
        for (int j = 0; j < chars1.length; j++) {
            // 不是0拼接字符
            if (chars1[j] != 0) {
                builder.append(chars1[j]);
                // 若是0，判断是否首位为0或者前一位不为0
            } else if (j == 0 || chars1[j - 1] != 0) {
                builder.append(to);
            }
        }
        return builder.toString();
    }

    public static void main(String[] args) {
        System.out.println(process("123abc", "abc", "4567"));
        System.out.println(process("123", "abc", "456"));
        System.out.println(process("123abcabc", "abc", "X"));
        System.out.println(process("1abc23abcabc", "abc", "X"));
    }
}
```

## 字符串的统计字符串

```java
/**
 * 字符串的统计字符串
 * 1、给定字符串，返回其统计字符串
 * 2、给出统计字符串和下标，返回对应的字符
 */
public class StringStatistic {

    /**
     * 给定一个字符串str,返回其统计字符串，例如String s="aaabbadddffc";其统计字符串形式为”a_3_b_2_a_1_d_3_f_2_c_1“
     * 时间复杂度：O(N)   空间复杂度：O(N)，N为字符串长度
     *
     * @param str 字符串
     * @return 统计后字符串
     */
    public static String process(String str) {
        if (str == null || str.length() == 0) {
            return str;
        }
        StringBuilder builder = new StringBuilder();
        char[] chars = str.toCharArray();
        int cnt = 1;
        // 从下标1开始，与前一个字符比较是否相等，并计数
        for (int i = 1; i < chars.length; i++) {
            if (chars[i] == chars[i - 1]) {
                cnt++;
            } else {
                // 首次连续不相等，拼接连续字符与连续次数
                builder.append(chars[i - 1]).append("_").append(cnt).append("_");
                // 重置连续次数
                cnt = 1;
            }
        }
        // 拼接最后一个字符及连续次数
        builder.append(chars[chars.length - 1]).append("_").append(cnt);
        return builder.toString();
    }

    /**
     * 给定一个字符串的统计字符串，再给定一个整数，返回原始字符串上该整数上的字符
     * 例如："a_1_b_100"所代表的原始字符串上第0个字符是'a',第50个字符是'b'
     *
     * @param str   统计字符串
     * @param index 第N个字符，从0开始
     * @return 第index位的字符
     */
    public static char process2(String str, int index) {
        if (str == null || str.length() == 0 || index < 0) {
            return 0;
        }
        char[] chars = str.toCharArray();
        char cur = chars[0];
        // 第0位直接返回首位字符
        if (index == 0) {
            return cur;
        }
        // 是否数字位
        boolean isNum = false;
        int res = 0;
        int num = 0;
        for (int i = 1; i < chars.length; i++) {
            // 首次出现即为数字位，这里使用isNum=!isNum逻辑上更简单，不用在其他分支逻辑中处理是否为数字位
            if (chars[i] == '_') {
                isNum = true;
            } else if (isNum) {
                // 计算当前字符出现次数
                num = num * 10 + (chars[i] - '0');
                // 判断数字位是否结束，使用方法3在字符上计算更简单
                if (i + 1 < chars.length && chars[i + 1] == '_') {
                    // 计算当前总出现次数
                    res += num;
                    // 大于index直接返回当前字符即可
                    if (num > index) {
                        return cur;
                    }
                    // 当前字符出现次数归0
                    num = 0;
                    // 数字位结束
                    isNum = false;
                    // 跳过下一个字符'_'，第一个分支是isNum=true
                    i++;
                }
            } else {
                // 记录当前字符
                cur = chars[i];
            }
        }
        // 累计计数，处理字符为末位的情况
        res += num;
        return res > index ? cur : 0;
    }

    /**
     * 给定一个字符串的统计字符串，再给定一个整数，返回原始字符串上该整数上的字符
     * 例如："a_1_b_100"所代表的原始字符串上第0个字符是'a',第50个字符是'b'
     * 巧妙的使用了字符成对出现定位字符位，比process2逻辑简单
     *
     * @param str   统计字符串
     * @param index 第N个字符
     * @return 第index位的字符
     */
    public static char process3(String str, int index) {
        if (str == null || str.length() == 0 || index < 0) {
            return 0;
        }
        char[] chars = str.toCharArray();
        // 当前字符
        char cur = 0;
        // 当字符总数
        int num = 0;
        // 总字符串数
        int sum = 0;
        // 当前下标是否字符
        boolean flag = true;
        for (char aChar : chars) {
            if (aChar == '_') {
                // 字符'_'成对出现的，flag取反刚好代表是否字符位
                flag = !flag;
            } else if (flag) {
                // 累加计数
                sum += num;
                // 大于index直接返回当前字符即可
                if (sum > index) {
                    return cur;
                }
                // 记录当前字符
                cur = aChar;
                // 当前字符计数归0
                num = 0;
            } else {
                // 计算当前字符次数
                num = num * 10 + aChar - '0';
            }
        }
        return sum + num > index ? cur : 0;
    }

    /**
     * 给定一个字符串的统计字符串，再给定一个整数，返回原始字符串上该整数上的字符
     * 例如："a_1_b_100"所代表的原始字符串上第0个字符是'a',第50个字符是'b'
     * 使用了字符'_'成对出现定位字符位，和process3类型，相比逻辑更直观
     *
     * @param str   统计字符串
     * @param index 第N个字符
     * @return 第index位的字符
     */
    public static char process4(String str, int index) {
        if (str == null || str.length() == 0) {
            return 0;
        }
        char[] chars = str.toCharArray();
        // 当前字符
        char cur;
        // 当字符总数
        int num = 0;
        // 总字符串数
        int sum = 0;
        // 利用“_”成对出现的特性，在循环内右移下标获取字符和出现次数
        for (int i = 0; i < chars.length; i++) {
            // 获取当前字符，下标右移
            cur = chars[i++];
            // 下标持续右移直到第二次出现‘_’为止，计算出现次数
            while (i + 1 < chars.length && chars[++i] != '_') {
                num = num * 10 + (chars[i] - '0');
            }
            // 累加计数
            sum += num;
            // 大于index直接返回当前字符即可
            if (sum > index) {
                return cur;
            }
            // 当前字符计数归0
            num = 0;
        }
        return 0;
    }

    public static void main(String[] args) {
        System.out.println(process("aaabbadddffc"));
        System.out.println(process2("a_1_b_100", 0));
        System.out.println(process2("a_1_b_100", 50));
        System.out.println(process3("a_1_b_100", 0));
        System.out.println(process3("a_1_b_100", 50));
        System.out.println(process4("a_1_b_100", 0));
        System.out.println(process4("a_1_b_100", 50));
    }
}
```

## 判断字符数组中是否所有字符都只出现过一次

```java
/**
 * 判断字符数组中是否所有字符都出现过一次
 * 1、实现时间复杂度为O(N)的方法
 * 2、在保证额外空间复杂度为O(1)的前提下，实现时间复杂度尽量低的方法
 */
public class CharOnce {

    /**
     * 判断字符数组中是否所有字符都出现过一次
     * 时间复杂度：O(N)   N为字符串长度
     *
     * @param chars 字符数组
     * @return true/false
     */
    public static boolean process1(char[] chars) {
        if (chars == null || chars.length == 0) {
            return false;
        }
        //
        int[] map = new int[256];
        for (char c : chars) {
            if (map[c] == 0) {
                map[c] = 1;
            } else {
                return false;
            }
        }
        return true;
    }

    /**
     * 判断字符数组中是否所有字符都出现过一次
     * 空间复杂度：O(1) 此处采用堆排序
     *
     * @param chars 字符数组
     * @return true/false
     */
    public static boolean process2(char[] chars) {
        // 参考排序算法中堆排序
        heapSort(chars);
        for (int i = 1; i < chars.length; i++) {
            if (chars[i] == chars[i - 1]) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        System.out.println(process1(new char[]{'a', 'b', 'c'}));
        System.out.println(process1(new char[]{'1', '2', '1'}));
        System.out.println(process2(new char[]{'a', 'b', 'c'}));
        System.out.println(process2(new char[]{'1', '2', '1'}));
    }
}
```

## 在有序但含有空的数组中查找字符串

```java
/**
 * 在有序但含有空的数组中查找字符串
 * 给定一个字符串数组strs[]，在strs中有些位置为null，但在不为null的位置上，其字符串是按照字典顺序由小到大依次出现的。
 * 再给定一个字符串str，请返回str在strs中出现的最左的位置
 */
public class StringSearch {

    /**
     * 在有序但含有空的数组中查找字符串，使用二分查找
     *
     * @param strs 字符串数组
     * @param str  待查找字符串
     * @return 出现位置
     */
    public static int process(String[] strs, String str) {
        // 字符串数组为空或者待查找字符串为空，直接返回-1
        if (strs == null || strs.length == 0 || str == null) {
            return -1;
        }
        // 默认位置-1
        int pos = -1;
        // 查找左边界
        int left = 0;
        // 查找右边界
        int right = strs.length - 1;
        // 查找范围中心位置，用于二分查找
        int mid;
        // 临时下标
        int ix;
        // 在有效范围内查找
        while (left < right) {
            mid = (left + right) / 2;
            // 若二分点刚好不为空且相等，记录位置点，在左边继续查找(因为需要找出最左匹配元素)
            if (strs[mid] != null && str.equals(strs[mid])) {
                // 缩小右边界
                right = mid - 1;
                // 记录最右匹配位置
                pos = mid;
                // 如果不相等且不为空，与待查找元素比较决定向左还是向右查找
            } else if (strs[mid] != null) {
                if (strs[mid].compareTo(str) > 0) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
                // 如果二分点为空，向左找出首个不为空的元素
            } else {
                // 向左移动查找首个不为空的元素
                ix = mid - 1;
                while (ix >= left && strs[ix] == null) {
                    ix--;
                }
                // 如果二分点左边元素都为空，或者首个不为空元素小于待查找元素，向右查找
                if (strs[left] == null || strs[left].compareTo(str) < 0) {
                    left = mid + 1;
                    // 反之向左查找
                } else {
                    // 若首个不为空元素等于待查找元素，需要记录最右匹配位置
                    pos = strs[left].equals(str) ? ix : pos;
                    // 调整右边界
                    right = ix - 1;
                }
            }
        }
        return pos;
    }

    public static void main(String[] args) {
        System.out.println(process(new String[]{null, "a", null, "a", null, "b", null, "c"}, "a"));
        System.out.println(process(new String[]{null, "a", null, "a", null, "b", null, "c"}, null));
        System.out.println(process(new String[]{null, "a", null, "a", null, "b", null, "c"}, "d"));
    }
}
```

## 字符串的调整与替换

```java
/**
 * 字符串的调整与替换
 * 1、给定一个字符类型的数组，右半区全是空字符，左半区不含有空字符。在右半区足够大情况下，把左半区中所有空格字符替换成“%20”
 * 2、给定一个字符类型的数组，其中只含有数字字符和“*”字符，把所有“*”挪到左边，数字挪到右边，且不改变数字顺序
 */
public class StringChange {

    /**
     * 给定一个字符类型的数组，右半区全是空字符，左半区不含有空字符。在右半区足够大情况下，把左半区中所有空格字符替换成“%20”
     * 时间复杂度O(N)，额外空间复杂度为O(1)
     *
     * @param chars 字符数组
     * @return 替换后字符数组
     */
    public static char[] process1(char[] chars) {
        // 字符串数组为空或者待查找字符串为空，直接返回-1
        if (chars == null || chars.length == 0) {
            return chars;
        }
        int leftLen = 0;
        int emptyLen = 0;
        int ix = 0;
        while (ix < chars.length && chars[ix] != 0) {
            if (chars[ix] == ' ') {
                emptyLen++;
            }
            leftLen++;
            ix++;
        }
        int endIx = leftLen + 2 * emptyLen - 1;
        if (endIx >= chars.length) {
            throw new RuntimeException("no enough blank char in right");
        }
        for (int i = ix - 1; i >= 0; i--) {
            if (chars[i] == ' ') {
                chars[endIx--] = '0';
                chars[endIx--] = '2';
                chars[endIx--] = '%';
            } else {
                chars[endIx--] = chars[i];
            }
        }
        return chars;
    }

    /**
     * 给定一个字符类型的数组，其中只含有数字字符和“*”字符，把所有“*”挪到左边，数字挪到右边，且不改变数字顺序
     * 时间复杂度O(N)，额外空间复杂度为O(1)
     * 注意：从左边开始使用双指针可能改变数字顺序，因为左边数字不够多时，同一数字可能多次交换
     *
     * @param chars 字符数组
     * @return 替换后字符数组
     */
    public static char[] process2(char[] chars) {
        if (chars == null || chars.length == 0) {
            return chars;
        }
        // 倒序把数字移到右边
        int j = chars.length - 1;
        for (int i = chars.length - 1; i >= 0; i--) {
            if (chars[i] != '*') {
                chars[j--] = chars[i];
            }
        }
        // 左边剩余位置补*
        while (j >= 0) {
            chars[j--] = '*';
        }
        return chars;
    }

    public static void main(String[] args) {
        System.out.println(process1(new char[]{'a', ' ', 'b', ' ', ' ', 'c', 0, 0, 0, 0, 0, 0, 0}));
        System.out.println(process2(new char[]{'1', '2', '*', '*', '*', '4', '5'}));
    }
}
```

## 翻转字符串

```java
/**
 * 翻转字符串
 * 1、给定一个字符串，在单词间做逆序调整，只需要单词顺序逆序即可
 * 2、给定一个字符串和整数size，把大小为size的左半区整体与右半区交换位置
 */
public class Demo {

    /**
     * 给定一个字符串，在单词间做逆序调整，只需要单词顺序逆序即可
     * 例如：dog loves pig，调整为：pig loves dog
     * 时间复杂度O(N)，额外空间复杂度为O(1)
     *
     * @param str 字符串
     * @return 逆序后字符串
     */
    public static String reverse1(String str) {
        if (str == null || str.length() == 0) {
            return str;
        }
        char[] chars = str.toCharArray();
        // 首先整体逆序
        reverse(chars, 0, chars.length - 1);
        // 空格分隔后，依次逆序每一部分
        int start = 0;
        int end = 0;
        for (char aChar : chars) {
            if (aChar == ' ') {
                reverse(chars, start, end - 1);
                start = end + 1;
                end = start;
            } else {
                end++;
            }
        }
        // 逆序最后一部分
        reverse(chars, start, end - 1);
        return String.valueOf(chars);
    }

    /**
     * 给定一个字符串和整数size，把大小为size的左半区整体与右半区交换位置
     * 例如：字符串“ABCDE”，size=3，调整为：DEABC
     * 时间复杂度O(N)，额外空间复杂度为O(1)
     *
     * @param str 字符串
     * @return 逆序后字符串
     */
    public static String reverse2(String str, int size) {
        if (str == null || str.length() == 0 || size > str.length()) {
            return str;
        }
        char[] chars = str.toCharArray();
        int len = chars.length;
        // 整体逆序
        reverse(chars, 0, len - 1);
        // 根据size拆分为两部分，分别逆序
        reverse(chars, 0, len - size - 1);
        reverse(chars, len - size, len - 1);
        return String.valueOf(chars);
    }

    /**
     * 字符数组指定范围倒序
     *
     * @param chars 字符数组
     * @param left  左边界
     * @param right 右边界
     */
    private static void reverse(char[] chars, int left, int right) {
        char tmp;
        while (left < right) {
            tmp = chars[left];
            chars[left] = chars[right];
            chars[right] = tmp;
            left++;
            right--;
        }
    }

    public static void main(String[] args) {
        System.out.println(reverse1("dog loves pig"));
        System.out.println(reverse1("I'm a student."));
        System.out.println(reverse2("ABCDE", 3));
        System.out.println(reverse2("1234567ABCD", 7));
    }
}
```

## 数组中两个字符串的最小距离

```java
/**
 * 数组中两个字符串的最小距离
 * 1、给定一个字符串数组strs，再给定两个字符串str1和str2，返回strs中str1和str2的最小距离
 * 2、如果查询发送很多次，每次查询时间复杂度降为O(1)
 */
public class StringDistance {

    /**
     * 给定一个字符串数组strs，再给定两个字符串str1和str2，返回strs中str1和str2的最小距离
     * 例如：["1", "3", "3", "2", "2", "3", "1"]，字符串"1"、"2"的最小距离为2
     * 时间复杂度O(N)，额外空间复杂度为O(1)
     *
     * @param strs 字符串数组
     * @param str1 字符串1
     * @param str2 字符串2
     * @return 最小距离
     */
    public static int process1(String[] strs, String str1, String str2) {
        // 数组为空、字符串为空无法计算最小距离返回-1
        if (strs == null || strs.length == 0 || str1 == null || str2 == null) {
            return -1;
        }
        // 默认最小距离为-1
        int min = -1;
        // str1出现位置
        int m = -1;
        // str2出现位置
        int n = -1;
        // 遍历字符串数组
        for (int i = 0; i < strs.length; i++) {
            // 如果当前字符串等于str1
            if (str1.equals(strs[i])) {
                // 判断str2是否已经出现，出现即可计算最小距离
                if (n != -1) {
                    // min=-1时当前距离记为最小距离，反之与前一次比较取最小值
                    min = min == -1 ? i - n : Math.min(min, i - n);
                }
                // 记录str1出现位置
                m = i;
            }
            // 如果当前字符串等于str2
            if (str2.equals(strs[i])) {
                // 判断str1是否已经出现，出现即可计算最小距离
                if (m != -1) {
                    // min=-1时当前距离记为最小距离，反之与前一次比较取最小值
                    min = min == -1 ? i - m : Math.min(min, i - m);
                }
                // 记录str2出现位置
                n = i;
            }
        }
        return min;
    }

    /**
     * 记录数组中任意两个字符串的距离，例如(key1,(key2,distance))
     */
    private Map<String, Map<String, Integer>> distanceMap = new HashMap<>();

    /**
     * 构建实例并初始化数组中任意两个字符串的距离
     *
     * @param strs 字符串数组
     */
    public Demo(String[] strs) {
        if (strs != null) {
            // 记录数组中元素最新出现位置
            Map<String, Integer> indexMap = new HashMap<>();
            // (key2,distance)
            Map<String, Integer> recordMap;
            // 当前元素
            String cur;
            for (int i = 0; i < strs.length; i++) {
                cur = strs[i];
                // 构建当前元素对应其他元素距离集合(key1,(key2,distance))
                distanceMap.putIfAbsent(cur, new HashMap<>());
                // 获取当前元素对应其他元素距离集合
                recordMap = distanceMap.get(cur);
                // 遍历之前已经遍历过的元素
                for (Map.Entry<String, Integer> entry : indexMap.entrySet()) {
                    // 已遍历的元素
                    String key = entry.getKey();
                    // 排除和当前元素一样元素
                    if (!key.equals(cur)) {
                        // 已遍历元素的下标
                    	int value = entry.getValue();
                        // 两个不同元素之间的距离
                        int distance = i - value;
                        // 判断之前是否已经计算过
                        if (recordMap.containsKey(key)) {
                            // 计算过取两次中最小值
                            int preMin = recordMap.get(key);
                            if (distance < preMin) {
                                recordMap.put(key, distance);
                                distanceMap.get(key).put(cur, distance);
                            }
                        } else {
                            // 未计算过取当前距离作为最小距离
                            recordMap.put(key, distance);
                            // 建立反向关系
                            distanceMap.get(key).put(cur, distance);
                        }
                    }
                }
                indexMap.put(cur, i);
            }
        }
    }

    /**
     * O(1)查询字符串数组中任意两个字符串str1和str2的最小距离
     * 例如：["1", "3", "3", "2", "2", "3", "1"]，字符串"1"、"2"的最小距离为2
     * 时间复杂度O(1)
     *
     * @param str1 字符串1
     * @param str2 字符串2
     * @return 最小距离
     */
    public int process2(String str1, String str2) {
        if (str1 == null || str2 == null) {
            return -1;
        }
        // 如果两个元素相等，判断是否存在数组中，存在之间返回0
        if (str1.equals(str2) && distanceMap.containsKey(str1)) {
            return 0;
        }
        // 若数组中存在这两个元素，直接返回最小距离即可
        if (distanceMap.containsKey(str1) && distanceMap.get(str1).containsKey(str2)) {
            return distanceMap.get(str1).get(str2);
        }
        return -1;
    }

    public static void main(String[] args) {
        System.out.println(process1(new String[]{"1", "3", "3", "2", "2", "3", "1"}, "1", "2"));
        System.out.println(process1(new String[]{"CD"}, "CD", "AB"));
        StringDistance stringDistance = new StringDistance(new String[]{"1", "3", "3", "2", "2", "3", "1"});
        System.out.println(stringDistance.process2("1", "2"));
        System.out.println(stringDistance.process2("3", "3"));
    }
}
```

